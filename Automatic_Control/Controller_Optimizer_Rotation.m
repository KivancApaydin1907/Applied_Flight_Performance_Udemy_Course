%% ========================================================================
%  PROJECT: T-38 TALON FLIGHT DYNAMICS & CONTROL
%  MODULE:  AUTOMATIC PID TUNER - ROTATION PHASE
%  ========================================================================
%  AUTHOR:      Kıvanç Apaydın
%  DATE:        01/2026
%  PLATFORM:    MATLAB R2025b
%
%  DESCRIPTION:
%     This script optimizes the Pitch Controller gains (Kp, Kd) specifically
%     for the takeoff rotation maneuver. It utilizes the 'fminsearch' 
%     algorithm (Nelder-Mead simplex method) to minimize a cost function 
%     based on tracking error and actuator usage.
%
%     Key Features:
%     1. Loads initialization data from 'Rotation_Checkpoint.mat'.
%     2. Enforces a "Soft Constraint" on actuator saturation.
%     3. Enforces a "Hard Barrier" penalty for pitch overshoot (> 12.5 deg)
%        to prevent tail strikes or unstable climbs.
%     4. Visualizes the step response of the optimized controller.
%
%  DEPENDENCIES:
%     - FlightDynamics.m
%     - RunPID.m
%     - atmosisa.m
%     - Rotation_Checkpoint.mat (Generated by the main simulation)
% ========================================================================
clearvars; clc; close all;

%% ========================================================================
%  1. INITIALIZATION & CONFIGURATION
%  ========================================================================
fprintf('----------------------------------------------------------\n');
fprintf('>> T-38 ROTATION CONTROLLER TUNER INITIATED.\n');
fprintf('----------------------------------------------------------\n');

% Check for required data file
if ~isfile('Rotation_Checkpoint.mat')
    error('>> ERROR: Checkpoint file "Rotation_Checkpoint.mat" not found. Run the main simulation first.');
end

% Load the snapshot of the aircraft state right before rotation
load('Rotation_Checkpoint.mat', 'Checkpoint');
fprintf('>> Checkpoint Loaded. Simulation Time: %.2f s\n', Checkpoint.Time);

% --- TUNING CONFIGURATION ---
% Target: Rotate to 12 degrees pitch attitude
TunerConfig.Target_Theta = deg2rad(12.0); 
% Constraint: Do not exceed 12.5 degrees (Overshoot Barrier)
TunerConfig.Max_Theta    = deg2rad(12.5); 
% Actuator Limits: +/- 15 degrees elevator
TunerConfig.Limit_Pos    = deg2rad(15.0);
TunerConfig.Limit_Neg    = -deg2rad(15.0);

% --- OPTIMIZATION SETTINGS ---
% Initial Guess for Gains [Kp, Ki, Kd]
% Note: Ki is forced to 0.0 internally to prevent integrator windup 
% during this short-duration transient maneuver.
InitialGuess = [-2.0, 0.0, 1.5]; 

% Solver Options (Nelder-Mead)
Opts = optimset('Display', 'iter', ...
                'MaxIter', 500, ...
                'TolX', 1e-4, ...
                'TolFun', 1e-4);

%% ========================================================================
%  2. EXECUTE OPTIMIZATION
%  ========================================================================
fprintf('>> Starting Optimization Loop (Objective: Minimize Tracking Error + Overshoot)...\n');

% Define the Cost Function handle
CostFunc = @(Gains) EvaluateRotationPerformance(Gains, Checkpoint, TunerConfig);

% Run Optimization
[OptimalGains, MinCost] = fminsearch(CostFunc, InitialGuess, Opts);

%% ========================================================================
%  3. REPORT RESULTS
%  ========================================================================
fprintf('\n==========================================================\n');
fprintf('OPTIMIZATION COMPLETE.\n');
fprintf('==========================================================\n');
fprintf('Final Cost: %.4f\n', MinCost);
fprintf('Optimized Gains:\n');
fprintf('   Kp (Proportional): %8.5f  [Stiffness]\n', OptimalGains(1));
fprintf('   Ki (Integral):     %8.5f  [Forced to 0]\n', 0.0);
fprintf('   Kd (Derivative):   %8.5f  [Damping]\n', OptimalGains(3));
fprintf('==========================================================\n');

% Visualize the performance of the optimal gains
VisualizePerformance(OptimalGains, Checkpoint, TunerConfig);

%% ========================================================================
%  LOCAL FUNCTION: COST FUNCTION EVALUATION
%  ========================================================================
function J = EvaluateRotationPerformance(Gains, CP, Config)
    % Unpack Gains
    Kp = Gains(1);
    Ki = 0.0;       % Integrator disabled for rotation phase
    Kd = Gains(3);

    % --- STABILITY CONSTRAINTS (PENALTY BARRIERS) ---
    % 1. Kp must be negative (Standard pitch-up convention for this model)
    % 2. Kd must be positive (to provide damping)
    if Kp > -0.5 || Kd < 0 
        J = 1e10; % Infinite penalty for invalid signs
        return;
    end

    % Setup Controller Config for the Simulation
    ControlConfig.Kp  = Kp; 
    ControlConfig.Ki  = Ki; 
    ControlConfig.Kd  = Kd;
    ControlConfig.Max = Config.Limit_Pos; 
    ControlConfig.Min = Config.Limit_Neg;
    
    % Initialize Simulation State from Checkpoint
    State    = CP.StateVector; 
    AC       = CP.AC; 
    Env      = CP.Env; 
    dt       = CP.dt;
    PIDState = struct('Integrator', 0, 'PrevError', 0);
    
    % Initialize Counters & Metrics
    Step = 0; 
    MaxSteps = 600; % Max duration limit (approx 6 seconds)
    Controls = struct('ElevatorDeflection',0, 'ThrottleSetting',1.0, 'Gear',1.0);
    
    % Initial Physics Call
    Current_Log = FlightDynamics(State, AC, Env, Controls);
    
    % Performance Accumulators
    Total_Error = 0;
    Saturation_Penalty = 0;
    Max_Theta_Reached = 0;
    
    % --- SIMULATION LOOP ---
    % Run until nose gear lifts off (Normal Force < 0 is not sufficient alone, 
    % usually we check for main gear liftoff or target attitude). 
    % Here: Run as long as main gear is on ground OR until stable climb.
    % Adapted Logic: Run while Normal Force is positive (Ground) or strictly for time limit.
    % For tuner, we run until N < 0 (Lift-off) to evaluate the rotation curve.
    
    while Current_Log.Forces.N < 0 && Step < MaxSteps
        Step = Step + 1;
        Derv = Current_Log.Derivatives;
        
        % Euler Integration
        State.x_E   = State.x_E   + Derv.x_dot_E * dt;
        State.z_E   = State.z_E   + Derv.z_dot_E * dt;
        State.u     = State.u     + Derv.u_dot * dt;
        State.w     = State.w     + Derv.w_dot * dt;
        State.theta = State.theta + Derv.theta_dot * dt;
        State.q     = State.q     + Derv.q_dot * dt;
        State.m     = State.m     + Derv.m_dot * dt;
        
        % Update Velocity Vector
        V_tot = sqrt(State.u^2 + State.w^2);
        State.u = V_tot * cos(State.theta);
        State.w = V_tot * sin(State.theta);
        
        % Update Environment
        [~, Env.a, ~, Env.rho] = atmosisa(-State.z_E);
        
        % Execute Control Law
        [delta_cmd, PIDState] = RunPID(Config.Target_Theta, State.theta, dt, ...
                                       ControlConfig, PIDState, State.q);
        
        % Physics Step
        Controls.ElevatorDeflection = delta_cmd;
        Current_Log = FlightDynamics(State, AC, Env, Controls);
        
        % --- COST CALCULATION ---
        % 1. Tracking Error (Integral of Absolute Error)
        Total_Error = Total_Error + abs(Config.Target_Theta - State.theta);
        
        % 2. Saturation Penalty (Avoid banging the stops)
        % Penalize if actuator is within 0.1 deg of the limit
        if abs(delta_cmd) >= (ControlConfig.Max - deg2rad(0.1))
            Saturation_Penalty = Saturation_Penalty + 50; 
        end
        
        % Track Maximum Pitch Angle for Barrier
        if State.theta > Max_Theta_Reached
            Max_Theta_Reached = State.theta;
        end
    end
    
    % --- POST-RUN PENALTIES ---
    
    % 1. Overshoot Barrier (Crucial for safety)
    % If pitch exceeds 12.5 deg, apply exponential penalty.
    Overshoot_Penalty = 0;
    if Max_Theta_Reached > Config.Max_Theta
        Overshoot_Penalty = 1e6 * (Max_Theta_Reached - Config.Max_Theta);
    end
    
    % 2. Failure to Rotate
    % If simulation timed out without lifting off
    LiftOffPenalty = 0;
    if Step >= MaxSteps
        LiftOffPenalty = 50000; 
    end
    
    % Total Cost
    J = Total_Error + Saturation_Penalty + Overshoot_Penalty + LiftOffPenalty;
end

%% ========================================================================
%  LOCAL FUNCTION: VISUALIZATION
%  ========================================================================
function VisualizePerformance(Gains, CP, Config)
    % Re-simulate with optimal gains for plotting
    Kp = Gains(1); Ki = 0; Kd = Gains(3);
    
    ControlConfig.Kp = Kp; ControlConfig.Ki = Ki; ControlConfig.Kd = Kd;
    ControlConfig.Max = Config.Limit_Pos; ControlConfig.Min = Config.Limit_Neg;
    
    State = CP.StateVector; AC = CP.AC; Env = CP.Env; dt = CP.dt;
    PIDState = struct('Integrator', 0, 'PrevError', 0);
    
    % Data Arrays for Plotting
    T_Hist = []; Theta_Hist = []; Elev_Hist = [];
    Step = 0; 
    Controls = struct('ElevatorDeflection',0, 'ThrottleSetting',1.0, 'Gear',1.0);
    Current_Log = FlightDynamics(State, AC, Env, Controls);
    
    % Simulation Loop (Same as Cost Function)
    while Current_Log.Forces.N < 0 && Step < 600
        Step = Step + 1;
        Derv = Current_Log.Derivatives;
        
        State.x_E   = State.x_E   + Derv.x_dot_E * dt;
        State.z_E   = State.z_E   + Derv.z_dot_E * dt;
        State.u     = State.u     + Derv.u_dot * dt;
        State.w     = State.w     + Derv.w_dot * dt;
        State.theta = State.theta + Derv.theta_dot * dt;
        State.q     = State.q     + Derv.q_dot * dt;
        State.m     = State.m     + Derv.m_dot * dt;
        
        V_tot = sqrt(State.u^2 + State.w^2);
        State.u = V_tot * cos(State.theta);
        State.w = V_tot * sin(State.theta);
        [~, Env.a, ~, Env.rho] = atmosisa(-State.z_E);
        
        [delta_cmd, PIDState] = RunPID(Config.Target_Theta, State.theta, dt, ...
                                       ControlConfig, PIDState, State.q);
                                   
        Controls.ElevatorDeflection = delta_cmd;
        Current_Log = FlightDynamics(State, AC, Env, Controls);
        
        % Record Data
        T_Hist(Step)     = Step * dt;
        Theta_Hist(Step) = rad2deg(State.theta);
        Elev_Hist(Step)  = rad2deg(delta_cmd);
    end
    
    % --- PLOTTING ---
    figure('Color','w', 'Name', 'Optimized Rotation Response');
    
    % Subplot 1: Pitch Attitude
    subplot(2,1,1); 
    plot(T_Hist, Theta_Hist, 'LineWidth', 2, 'Color', [0 0.4470 0.7410]);
    yline(rad2deg(Config.Target_Theta), '--r', 'Target (12^\circ)', 'LineWidth', 1.5);
    yline(rad2deg(Config.Max_Theta), '--k', 'Barrier (12.5^\circ)', 'LineWidth', 1.5);
    grid on; grid minor;
    ylabel('Pitch Angle \theta (deg)'); 
    title('Optimized Rotation Response (No Overshoot)');
    legend('Response', 'Target', 'Safety Barrier', 'Location', 'Best');
    
    % Subplot 2: Elevator Control Effort
    subplot(2,1,2); 
    plot(T_Hist, Elev_Hist, 'LineWidth', 1.5, 'Color', [0.8500 0.3250 0.0980]);
    yline(rad2deg(Config.Limit_Neg), '--r', 'Limit (-15^\circ)');
    yline(rad2deg(Config.Limit_Pos), '--r');
    grid on; grid minor;
    ylabel('Elevator \delta_e (deg)'); 
    xlabel('Time (s)');
    ylim([-16 16]);
    title('Control Effort');
end